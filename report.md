---
title: "RES - Labo 5 - HTTP Infrastrucutre"
author: 
	- "Christopher Meier"
	- "Daniel Palumbo"
date: "11 june 2017"

toc: true

geometry: "margin=1in"
---

# Introduction

# Step 1: Static HTTP server with apache httpd

The Dockerfile for this step is in the `docker/httpd-static` folder.

Because of its familiar configuration, we choose to use the php official docker image (with apache) `php:7.0-apache`. We used the default configuration (situated at `/etc/apache2/`), so our site is copied to the default website folder at `/var/www/html`.

The choosen bootstrap one page template is named *Stylish Portfolio*.

```sh
	docker build ./docker/httpd-static -t res/httpd-static
	docker run -d --name "httpd-static" -p 8080:80 res/httpd-static
```

After running these commands the static website will be available on the host of the docker container at the port 8080.

# Step 2: Dynamic HTTP server with express.js

The Dockerfile for this step is in the `docker/express-dynamic` folder.

This docker image is based on the version 4.4 of *node*'s official docker image. We copy the source file of our app to `/opt/app` and install its dependancy with `npm install`

Our app listen on the port `3000` and returns a list of 1 to 8 tuples of streetname and city. The streets and city name are generated by the module `Chance.js`.

```sh
	docker build ./docker/express-dynamic -t res/express-dynamic
	docker run -d --name "express-dynamic" -p 3000:3000 res/express-dynamic
```

After running these commands the JSON payload of the app can be accessed on the host of the docker container at the port 3000.

# Step 3: Reverse proxy with apache (static configuration)

The Dockerfile for this step is in the `docker/httpd-reverse-proxy` folder.

This image is based on the same image as the one from step1. The module `proxy` and `proxy_http` used in this step need the setting of some environment variables (to define some options). The configuration of available sites are copied to `/etc/apache2/sites-available`. The last action of the Dockerfile is to enable the needed module and the configured sites.

The reverse proxy is configured so that only request having `demo.res.local` as host are forwarded to the content providers; so the host name resolution of the client must be configured to resolve `demo.res.local` to the ip address of the host of the docker container.

This configuration use hardcoded ip address for its forwarding, therefore the docker environment must be cleaned up and the containers must be started in the correct order.

```sh
	# Start step 1
	docker build ./docker/httpd-static -t res/httpd-static
	docker run -d --name "httpd-static" res/httpd-static

	# Start step 2
	docker build ./docker/express-dynamic -t res/express-dynamic
	docker run -d --name "express-dynamic" res/express-dynamic

	docker build ./docker/httpd-reverse-proxy -t res/httpd-reverse-proxy
	docker run -d --name "httpd-reverse-proxy" -p 8080:80 res/httpd-reverse-proxy
```

After running these commands and setting the host name resolution, the static site is available at `http://demo.res.local:8080/` and the JSON payload at `http://demo.res.local:8080/api/streets/`.

# Step 4: AJAX requests with JQuery

The Dockerfile for this step is in the `docker/httpd-reverse-proxy` folder.

This image is copied from the one in the first step. The only change is that the website loads the script at `httpdoc/js/streets.js` from the main page. This script instruct the navigator to send, every 2 seconds, an ajax request to get from 1 to 8 streets names and city and show them in the *Streets* zone of the main page.

The demonstration can't work without a reverse proxy because the cross-domain policy forbids an ajax query from querying a different domain.

As with step 3 the docker containers must be run in the correct order.

```sh
	# Start ajax
	docker build ./docker/httpd-ajax -t res/httpd-ajax
	docker run -d --name "httpd-ajax" res/httpd-ajax

	# Start step 2
	docker build ./docker/express-dynamic -t res/express-dynamic
	docker run -d --name "express-dynamic" res/express-dynamic

	# Start reverse-proxy
	docker build ./docker/httpd-reverse-proxy -t res/httpd-reverse-proxy
	docker run -d --name "httpd-reverse-proxy" -p 8080:80 res/httpd-reverse-proxy
```

After running these commands, the site can be reached at `http://demo.res.local:8080/` (like the last step, don't forget to set the redirection for the host).

# Step 5: Dynamic reverse proxy configuration

This part has been implemented in 2 different way.

The Dockerfile for the first one can be found in the `docker/httpd-dynamic-reverse-proxy` folder.

The image is mostly based on the step3 at the difference that it uses a script that will, at the start of the container, recuperate the IPs address needed for the different servers. The IPs are passed using environnement variables. The script uses *sed* (a stream editor for filtering and transforming text) to replace some tokens in the configuration file (`conf/sites-available/001-reverse-proxy.conf`) by the specified values (here the environnement variables) and then start the apache2 server.

```sh
  # Start step 4
  docker build ./docker/httpd-ajax -t res/httpd-ajax
  docker run -d --name "httpd-ajax" res/httpd-ajax

  # Start step 2
  docker build ./docker/express-dynamic -t res/express-dynamic
  docker run -d --name "express-dynamic" res/express-dynamic

  docker build ./docker/httpd-dynamic-reverse-proxy -t res/httpd-dynamic-reverse-proxy
  docker run -d --name "httpd-dynamic-reverse-proxy" \
  	-e IP_EXPRESS_DYNAMIC=<get_the_ip_adress_from_express-dynamic_image> \
	-e IP_HTTPD_AJAX=<get_the_ip_adress_from_httpd-ajax_image> -p 8080:80 \
	res/httpd-dynamic-reverse-proxy
```

The DockerFile for the other approach can be found in the `docker/httpd-dynamic-reverse-proxy-b folder`.

This approach use the `--link` feature from docker to link multiple containers together. It links the given hostname with the ip address of the specified container in the `resolv.conf` of the reverse-proxy container. In other words, it uses hostname instead of IP address' to target containers.

```sh
  # Start step 4
  docker build ./docker/httpd-ajax -t res/httpd-ajax
  docker run -d --name "httpd-ajax" res/httpd-ajax

  # Start step 2
  docker build ./docker/express-dynamic -t res/express-dynamic
  docker run -d --name "express-dynamic" res/express-dynamic

  docker build ./docker/httpd-dynamic-reverse-proxy-b -t res/httpd-dynamic-reverse-proxy-b
  docker run -d --name "httpd-dynamic-reverse-proxy-b" --link=httpd-ajax:httpd-ajax \
  	--link=express-dynamic:express-dynamic -p 8080:80 \
	res/httpd-dynamic-reverse-proxy-b
```

After running one of the 2 sets of commands, the site can be reached at `http://demo.res.local:8080/` (like the last step, don't forget to set the redirection for the host).

# Additionnal steps

To solve most additional steps, we choose to use Traefik. Traefik is reverse-proxy made to deploy microservices. It can listen to the docker socket to detect the presence, start up or shut down of containers and configure itself accordingly. Traefik support the use of the docker's label as configuration directives. These labels have been directly set in the Dockerfiles.

The configuration file that tells Traefik to listen to the docker socket is at `docker/traefik/traefik.toml`. It is copied to the `/etc/traefik/` folder in the container.

## Load balancing: multiple server nodes

With Traefik a container can announce itself as a particular service by naming this service in the `traefik.backend` label. If the service's port is not the default `80` it can be set with the `traefik.port` label.

The label `traefik.backend.rule` indicate which HTTP request must be forwarded to this particular service.

For our configuration some labels have been added to the Dockerfile of our services.

```sh
	# ./docker/httpd-ajax/Dockerfile
	LABEL "traefik.backend"="httpd-ajax"
	LABEL "traefik.frontend.rule"="Host: demo.res.local;PathPrefix: /"
```

These labels indicate that all HTTP requests having `demo.res.local` as host and having a path starting with `/` (that is not already requested by another service) should be directed to a docker container running an instance of the `httpd-ajax` service.

```sh
	# ./docker/express-dynamic/Dockerfile
	LABEL "traefik.backend"="express-dynamic"
	LABEL "traefik.port"="3000"
	LABEL "traefik.frontend.rule"="Host: demo.res.local;PathStrip: /api/streets/"
```

These labels indicate that all HTTP requests having `demo.res.local` as host and having `/api/streets/` as path should be directed (the path of the redirected request is `/`) to a docker container running an instance of the `express-dynamic` service.

## Load balancing: round-robin vs sticky sessions

Traefik has an option to enable or disable sticky session. The label `traefik.backend.loadbalancer.sticky` allow sticky session when set to `true` and round-robin when set to `false`.

```sh
	# ./docker/express-dynamic/Dockerfile
	LABEL "traefik.backend.loadbalancer.sticky"="false"
```

## Dynamic cluster management

Traefik use the events fired by the docker socket to update itself whenever a container has started or stopped.

## Management UI

We choose not to implement a management UI.

## Validation

Configure the host resolution and run the following command to set the environnement :

```sh
	# Start step 4
	docker build ./docker/httpd-ajax -t res/httpd-ajax
	docker run -d --name "httpd-ajax" res/httpd-ajax

	# Start step 2
	docker build ./docker/express-dynamic -t res/express-dynamic
	docker run -d --name "express-dynamic" res/express-dynamic

	# Start traefik reverse proxy
	docker build ./docker/traefik -t res/traefik
	docker run -d --name "traefik" -p 8000:8080 -p 8080:80 \
		-v /var/run/docker.sock:/var/run/docker.sock res/traefik
```

The site can now be reached at `http://demo.res.local:8080/` and the status page of Traefik can be reached at `http://demo.res.local:8000/`.

To start a new container for each service to test the dynamic cluster management run the following command :

```sh
	docker run -d res/httpd-ajax
	docker run -d res/express-dynamic
```

At any time the list of active service container can be found on Traefik's status page.

To see to which container service each request is forwarded to you can eavesdrop with wireshark or you can show Traefik debug information.

```sh
	docker attach traefik
```

The debug information allows the validation of each additional step. The port number of the redirected HTTP request allow the differentiation between the ajax request and the static page request.
